/** Declaration file generated by dts-gen */
declare module 'hyperdb' {
  export = hyperdb;

  class hyperdb {
    constructor(storage: string | Function);
    constructor(storage: string | Function, opts: hyperdb.options);
    constructor(
      storage: string | Function,
      key: Buffer | null | undefined,
      opts: hyperdb.options
    );

    authorize(key: any, cb: any): any;

    authorized(key: any, cb: any): any;

    batch(batch: any, cb: any): any;

    checkout(version: any, opts: any): any;

    createDiffStream(other: any, prefix: any, opts: any): any;

    createHistoryStream(opts: any): any;

    createReadStream(prefix: any, opts: any): any;

    createWriteStream(cb: any): any;

    del(key: any, cb: any): void;

    diff(other: any, prefix: any, opts: any): any;

    get(key: any, opts: any, cb: any): any;

    heads(cb: any): any;

    history(opts: any): any;

    iterator(prefix: any, opts: any): any;

    list(prefix: any, opts: any, cb: any): any;

    replicate(opts: any): any;

    snapshot(opts: any): any;

    key: Buffer;
    discoveryKey: Buffer;
    version(cb: (version: Version) => void): void;
    checkout(version: Version): void;
    put(key: string, value: string, cb?: hyperdb.dbCallBack): void;
    get(key: string, cb: hyperdb.dbCallBack): void;
    del(key: string, cb: hyperdb.dbCallBack): void;
    batch(batch: Batch[], cb?: hyperdb.dbCallBack): void;
    local: hyperdb.Feed;
    authorize(key: string, cb: () => void): void;
    authorized(key: string, cb: (err: string, auth: boolean) => void): void;
    watch(key: string, onchange: () => void): void;
    createReadStream(
      prefix: string,
      options?: { recursive: boolean; reverse: boolean; gt: boolean }
    ): void;
    feeds: hyperdb.Feed[];
    ready(cb: (err?: Error) => void): void;
    history(options: { reverse: boolean }): History;
    opened: boolean;
    _lock(
      cb: (
        release: (cb: (error: Error) => void, error: Error | null) => void
      ) => void
    ): void;
    heads(cb: (error: Error, heads: any) => void): void;
    _clock(): any;
    _byKey: Map<string, hyperdb.Writer>;
  }

  namespace hyperdb {
    interface options {
      map?(node: any): any; // map nodes before returning them
      reduce?(a: any, b: any): any; // reduce the nodes array before returning it
      firstNode?: boolean; // set to true to reduce the nodes array to the first node in it
      valueEncoding?: 'binary'; // set the value encoding of the db
      contentFeed?: boolean;
      checkout?: any;
    }

    interface Writer {
      _id: number;
      _db: hyperdb;
      _feed: Feed;
      _contentFeed: Feed;
      head: any;
      _mapList: any;
      _encodeMap: any;
    }
    interface Feed {
      key: any;
      length: number;
      seek(
        loc: number,
        options: { hash?: boolean },
        cb: (error: Error, index?: number, offset?: number) => void
      ): void;
      append(data: string, cb: (error: Error) => void): void;
      byteLength: number;
      get(
        index: number,
        optionsOrCb: { valueEncoding?: string } | feedGetCb,
        cb?: feedGetCb
      ): void;
      rootHashes(
        length: number,
        cb: (error: Error | null, roots: any[]) => void
      ): void;
      once: any;
    }
    type dbCallBack = (error: Error, nodes: any) => void;
    type feedGetCb = (error: Error, data: any) => void;
  }
}

// declare module "hyperdb" {
//   export = HyperDB;

//   function HyperDB(storage: string | Function): HyperDB.Database;
//   function HyperDB(
//     storage: string | Function,
//     opts: HyperDB.options
//   ): HyperDB.Database;
//   function HyperDB(
//     storage: string | Function,
//     key: Buffer | null | undefined,
//     opts: HyperDB.options
//   ): HyperDB.Database;

//   namespace HyperDB {
//     interface options {
//       map?(node: any): any; // map nodes before returning them
//       reduce?(a, b): any; // reduce the nodes array before returning it
//       firstNode?: boolean; // set to true to reduce the nodes array to the first node in it
//       valueEncoding?: "binary"; // set the value encoding of the db
//       contentFeed?: boolean;
//     }

//     export interface Database {
//       key: Buffer;
//       discoveryKey: Buffer;
//       version(cb: (version: Version) => void): void;
//       checkout(version: Version): void;

//       put(key: string, value: string, cb?: dbCallBack): void;
//       get(key: string, cb: dbCallBack): void;
//       del(key: string, cb: dbCallBack): void;

//       batch(batch: Batch[], cb?: dbCallBack): void;
//       local: Feed;

//       authorize(key: string, cb: () => void): void;
//       authorized(key: string, cb: (err: string, auth: boolean) => void): void;

//       watch(folderOrKey: string, onchange: () => void): void;

//       createReadStream(
//         prefix: string,
//         options?: { recursive: boolean; reverse: boolean; gt: boolean }
//       ): void;

//       feeds: Feed[];
//       ready(cb: (err?: Error) => void): void;

//       history(options: { reverse: boolean }): History;

//       opened: boolean;

//       _lock(
//         cb: (release: (cb: () => void, error: Error) => void) => void
//       ): void;

//       heads(cb: (error: Error, heads: any) => void): void;
//       _clock(): any;
//       _byKey: Map<string, Writer>;
//     }

//     interface Writer {
//       _id:number;
//       _db:HyperDB.Database;
//       _feed :Feed;
//       _contentFeed :Feed;
//     }

//     interface Feed {
//       key: any;
//       length: number;
//       seek(
//         loc: number,
//         options: { hash?: boolean },
//         cb: (error: Error, index?: number, offset?: number) => void
//       ): void;
//       append(data: string, cb: (error: Error) => void): void;
//       byteLength: number;
//       get(
//         index: number,
//         optionsOrCb: { valueEncoding?: string } | feedGetCb,
//         cb?: feedGetCb
//       ): void;
//       rootHashes(
//         length: number,
//         cb: (error: Error | null, roots: any[]) => void
//       ): void;
//     }
//     type dbCallBack = (error: Error, nodes: any) => void;
//     type feedGetCb = (error: Error, data: any) => void;
//   }
// }
