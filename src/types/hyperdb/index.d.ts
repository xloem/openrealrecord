/** Declaration file generated by dts-gen */
declare module 'hyperdb' {
  export = hyperdb;

  class hyperdb {
    constructor(storage: string | Function);
    constructor(storage: string | Function, opts: hyperdb.options);
    constructor(
      storage: string | Function,
      key: Buffer | null | undefined,
      opts: hyperdb.options
    );

    authorize(key: any, cb: any): any;

    authorized(key: any, cb: any): any;

    batch(batch: any, cb: any): any;

    checkout(version: any, opts: any): any;

    createDiffStream(other: any, prefix: any, opts: any): any;

    createHistoryStream(opts: any): any;

    createReadStream(prefix: any, opts: any): any;

    createWriteStream(cb: any): any;

    del(key: any, cb: any): void;

    diff(other: any, prefix: any, opts: any): any;

    get(key: any, opts: any, cb: any): any;

    heads(cb: any): any;

    history(opts: any): any;

    iterator(prefix: any, opts: any): any;

    list(prefix: any, opts: any, cb: any): any;

    replicate(opts: any): any;

    snapshot(opts: any): any;

    key: Buffer;
    discoveryKey: Buffer;
    version(cb: (version: Version) => void): void;
    checkout(version: Version): void;
    put(key: string, value: string, cb?: hyperdb.dbCallBack): void;
    get(key: string, cb: hyperdb.dbCallBack): void;
    del(key: string, cb: hyperdb.dbCallBack): void;
    batch(batch: Batch[], cb?: hyperdb.dbCallBack): void;
    local: hyperdb.Feed;
    authorize(key: string, cb: () => void): void;
    authorized(key: string, cb: (err: string, auth: boolean) => void): void;
    watch(key: string, onchange: () => void): void;
    createReadStream(
      prefix: string,
      options?: { recursive: boolean; reverse: boolean; gt: boolean }
    ): void;
    feeds: hyperdb.Feed[];
    ready(cb: (err?: Error) => void): void;
    history(options: { reverse: boolean }): History;
    opened: boolean;
    _lock(
      cb: (
        release: (cb: (error: Error) => void, error: Error | null) => void
      ) => void
    ): void;
    heads(cb: (error: Error, heads: any) => void): void;
    _clock(): any;
    _byKey: Map<string, hyperdb.Writer>;
  }

  namespace hyperdb {
    interface options {
      map?(node: any): any; // map nodes before returning them
      reduce?(a: any, b: any): any; // reduce the nodes array before returning it
      firstNode?: boolean; // set to true to reduce the nodes array to the first node in it
      valueEncoding?: 'binary'; // set the value encoding of the db
      contentFeed?: boolean;
      checkout?: any;
    }

    interface Writer {
      _id: number;
      _db: hyperdb;
      _feed: Feed;
      _contentFeed: Feed;
      head: any;
      _mapList: any;
      _encodeMap: any;
    }
    interface Feed {
      key: any;
      length: number;
      seek(
        loc: number,
        options: { hash?: boolean },
        cb: (error: Error, index?: number, offset?: number) => void
      ): void;
      append(data: string, cb: (error: Error) => void): void;
      byteLength: number;
      get(
        index: number,
        optionsOrCb: { valueEncoding?: string } | feedGetCb,
        cb?: feedGetCb
      ): void;
      rootHashes(
        length: number,
        cb: (error: Error | null, roots: any[]) => void
      ): void;
      once: any;
    }
    type dbCallBack = (error: Error, nodes: any) => void;
    type feedGetCb = (error: Error, data: any) => void;
  }
}
